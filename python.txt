可变与不可变类型：
    不可变类型（数字number、字符串string、元组tuple、不可变集合）：
        变量所指向的内存地址处的值是不可以被改变的，即：数据类型的对应变量的值发生了改变，它对应的内存地址也会发生改变
    可变类型（列表、字典、可变集合）:
        变量所指向的内存地址处的值是可以被改变的，即：数据类型的对应变量的值发生了改变，它对应的内存地址不必发生改变

深拷贝与浅拷贝实现方式、区别
    浅拷贝：拷贝的是浅层次的数据结构（不可变元素），此时拷贝的新对象的地址和原对象不同，但新对象中的可变元素的地址与原对象中的可变元素地址相同
    深拷贝：会开辟新的内存空间，同时将拷贝对象的数值拷贝进去；拷贝可变元素和不可变元素，此时拷贝的新对象的地址和原对象不同
example:
import copy
a = [1, 2, 3, 4, 5, ['a', 'b']]     # 原始对象
b = a                               # 赋值，传对象的引用
c = copy.copy(a)                    # 浅拷贝
d = copy.deepcopy(a)                # 深拷贝
a & b 和 a[5] & b[5] 地址完全相同
c & a 地址不同， c[5] & a[5] 地址完全相同
d & a 和 d[5] & a[5] 地址不同

__new__()和__init__()区别
    1.用法不同
        __new__()用于创建实例，所以该方法是在实例创建之前被调用，它是类级别的方法，是个静态方法
        __init__()用于初始化实例，所以该方法是在实例对象创建后被调用，它是实例级别的方法，用于设置对象属性的一些初始值
        由此可知，__new__()在__init__() 之前被调用。
        如果__new__() 创建的是当前类的实例，会自动调用__init__()函数，通过return调用的__new__()的参数cls来保证是当前类实例，如果是其他类的类名，那么创建返回的是其他类实例，就不会调用当前类的__init__()函数。
　　2.传入参数不同:
    　　__new__()至少有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别；
    　　__init__()至少有一个参数self，就是这个__new__()返回的实例，__init__()在__new__()的基础上完成一些初始化的操作。
    3.返回值不同:
    　　__new__()必须有返回值，返回实例对象；
    　　__init__()不需要返回值。

常见设计模式
    1. 创建型模式
        1. 单例模式：确保某一个类只有一个实例存在
        2. 工厂模式：用来创建对象的设计模式。包含一个超类，提供一个抽象化接口来创建要给特定的对象，而不是决定哪个对象可以被创建
        3. 建造者模式：将复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示；所有细节交给子类实现
        4. 原型模式：用原型实力指定创建对象的种类，并通过拷贝这些原型创建新的对象，本质是克隆对象
    2. 结构型模式
        1. 适配器模式： 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 
        2. 桥接模式：将抽象部分与实现部分分离，使它们都可以独立的变化。
        3. 组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性。 
        4. 外观模式：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
        5. 享元模式：运用共享技术有效地支持大量细粒度的对象。
        6. 代理模式：为其他对象提供一种代理以控制对这个对象的访问。主要解决：在直接访问对象时带来的问题
    3. 行为型模式
        1. 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。主要解决：一些方法通用，却在每一个子类都重新写了这一方法。
        2. 责任链模式： 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
        3. 观察者模式：定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。
        4. 策略模式：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

编码和解码：
    encode();decode();[ASCII码(英文大小写，字符), GB2312码(支持中文)，Unicode码(支持国际语言)，UTF-8码(支持国际语言)]
    数据通过编码decode转换成Unicode编码，编码的同时会将数据变成byte类型，通过解码encode转换为utf-8。

列表推导list comprehension和生成器的优劣：
    list_comp = [x ** 2 for x in range(10) if x % 2 == 0]   =>      [0, 4, 16, 36, 64]
    gen_exp = (x ** 2 for x in range(10) if x % 2 == 0)     =>      <generator object <genexpr> at 0x7f600131c410>
    生成器在列表中的主要优点是它占用的内存要少得多。
    生成器一次生成一个项目，因此它比列表更有内存效率。
    列表解析可以代替lambda, map, filter函数， 减少函数调用次数， 提高效率。
    生成器表达式并不创建一个真正的列表，返回一个生成器，每次调用next返回下一个元素，遍历完抛出stopIteration的异常，并且我们经常通过for循环来迭代它， 从而不需要关心stopIteration异常。

什么是装饰器，如果想在函数之后进行装饰应该怎么做：
    装饰器是一个函数，这个函数的主要作用是包装另一个函数或类。包装的目的是在不改变原函数名的情况下改变被包装对象的行为。
    接收一个函数，内部对其包装，然后返回一个新函数，这样子动态的增强函数功能。通过高阶函数传递函数参数，新函数添加旧函数的需求，然后执行旧函数。

使用装饰器实现的单例模式：
from functools import warps
def singleton(cls, *args, **kwargs):
    instance = {}
    def _instance():
        if cls is not in instance:
            instance[cls] = cls(*args, *kwargs)
        return instance[cls]
    return _instance
@singleton
class Test_singleton:
    def __init__(self):
        self.num = 0

使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别：
    使用装饰器单例属性不会被覆盖。因为装饰器单例模式是直接返回之前生成的对象，并不会重新初始化对象。
    像new方法构建的单例模式会重新调用init方法,为实例重新初始化属性。

邮箱地址正则表达式：
    pattern = '[a-zA-Z0-9_.-]+@[a-zA-Z0-9]+\.[a-z]'
身份证正则表达式：
    pattern = '^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$'

介绍下垃圾回收：引用计数/分代回收/孤立引用环：
    垃圾回收：python解释器对正在使用的对象保持计数，当某个对像的引用计数降为0时，垃圾收集器就可以释放该对象，获取分配的内存。当分配对象和取消分配对象的差值高于阈值时垃圾回收才会启动。
    分代回收：python将所有的对象分为0,1,2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。 如果0代经过一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0，1，2，即对所有对象进行扫描。

多进程与多线程的区别；CPU密集型适合用什么:
    多线程：
        在单个程序中同时运行多个线程完成不同的工作，称为多线程。
        线程共享内存空间；进程的内存是独立的，同一个进程的线程之间可以直接交流；两个进程想通信，必须通过一个中间代理来实现，一个线程可以控制和操作同一进程里的其他线程；但是进程只能操作子进程。
    1.多进程的优点是稳定性好，一个子进程崩溃了，不会影响主进程以及其余进程。缺点是创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源。
    2.多线程优点是效率较高一些，但是致命的缺点是任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。
*CPU密集型适合用多进程开发

进程通信的方式有几种:
    进程间通信主要包括管道、系统IPC(包括消息队列、信号量、共享存储)、socket

介绍下协程，为何比线程还快：
    高并发+高扩展性+低成本：一个CPU支持上万的协程都没问题，所以很适合用于高并发处理
    协程能保留上一次调用时的状态，不管是进程还是线程，每次阻塞切换都需要陷入系统调用，使用线程时需要非常小心处理同步问题，协程不存在这个问题。

range和xrange区别：
    用法完全相同，但返回的是一个生成器

is 和 == 的区别：is判断两个引用是否指向的是同一个变量，即内存id是否相等，==则是调用的__eq__方法，一般是用于判断值是否相等，也可以重写__eq__方法实现想要的效果。

dict与list的查找复杂度：dict用hash实现，查找的时间复杂度是O(1)，list则为O(n)。

如何运行一个字符串：eval和exec。

实现一个单例模式
实现一个装饰器

快排
堆排
二分查找

如何实现一个全局变量：
    1. global
    2. 通过单例模式

排序方法        时间复杂度(平均)    时间复杂度(最坏)	时间复杂度(最好)     空间复杂度      稳定性      复杂性
直接插入排序    O(n2)               O(n2)              O(n)                 O(1)            稳定	    简单
希尔排序	    O(nlog2n)	        O(n2)	           O(n1.3)	            O(1)        	不稳定	    较复杂
直接选择排序	O(n2)	            O(n2)	           O(n2)	            O(1)	        不稳定	    简单
堆排序	        O(nlog2n)	        O(nlog2n)	       O(nlog2n)	        O(1)	        不稳定	    较复杂
冒泡排序	    O(n2)	            O(n2)	           O(n)                 O(1)	        稳定        简单
快速排序	    O(nlog2n)	        O(n2)	           O(nlog2n)	        O(nlog2n)	    不稳定	    较复杂
归并排序	    O(nlog2n)	        O(nlog2n)	       O(nlog2n)	        O(n)	        稳定        较复杂
基数排序	    O(d(n+r))	        O(d(n+r))	       O(d(n+r))	        O(n+r)	        稳定        较复杂